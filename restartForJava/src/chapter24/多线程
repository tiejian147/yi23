多线程
    1、什么是进程？什么是线程？
        进程是一个应用程序；
        线程是一个进程当中的一个场景/执行单元；
        一个进程可以启动多个线程。
    2、java语言中，实现线程有两个方式？
        第一种方式：编写一个类，直接继承java.lang.Thread，重写run方法。
    3、线程的生命周期：
        新建状态；刚new出来的对象
        就绪状态；运行了start()方法
        运行状态；运行run()方法
        阻塞状态；遇到用户键盘输入或者sleep()方法时，会阻塞，放弃时间片
        死亡状态；run()方法结束，线程死亡。
    4、关于多线程并发环境下，数据安全问题；
        为什么这个是重点：
            以后在开发中，我们的项目都是运行在多线程的服务器中，而服务器已经将
            线程的开发，创建，启动都已经实现完了。这些代码不需要我们编写；
            最重要的是：你编写的程序放到一个多线程的环境当中，你最需要关注的是
                      你的这些数据在多并发环境下是否是安全的。
        什么时候数据在多线程并发的环境下会存在安全问题呢？
            三个条件：
                1、多线程的并发环境；
                2、有共享数据；
                3、共享数据有修改行为；
            满足以上三个条件，就会存在线程数据安全问题；
        怎么解决线程安全问题？
            线程排队执行；（不能并发）
            用排队执行解决线程安全问题；
            这种机制被称为：线程同步机制；
            语法：
              synchronized(){
                //线程同步代码块
              }
        涉及两个专业术语：
            异步编程模型：
                线程t1和线程t2，各自执行各自的，t1不管t2，t2也不用管t1；
                这种就叫做：异步编程模型；
                其实就是：多线程并发（效率较高）
                异步就是并发。
            同步编程模型：
                线程t1和线程t2，在线程t1执行的时候，必须等待t2线程执行结束，
                或者说在t2线程执行的时候，必须等待t1线程执行结束，两个线程之间
                发生了等待关系，这就是同步编程模型；
                效率较低，线程排队执行。
                同步就是排队。
    5、java中有三大变量：
        实例变量：在堆中
        静态变量：在方法区中
        局部变量：在栈中
        以上三个变量：
            局部变量永远都不会出现线程安全问题，因为局部变量不共享，
    总结：
        synchronized有两种写法：
            第一种：同步代码块
            灵活
            synchronized(线程共享对象){
                同步代码块
            }
            第二种：
            在实例方法上使用synchronized
            表示共享对象一定是this
            并且同步代码块是整个方法体；
            其实还有第三种方法：
            在静态方法上使用synchronized
            表示找类锁，类锁只有1把，就算创建了100个对象，类锁也只有1把。

            对象锁：一个对象一把锁；100个对象100把锁；
            类锁：100个对象也可能只是1把类锁；

    聊一聊：我们以后开发中应该怎么解决线程安全问题？
        是一上来就用synchronized吗？
        不是，synchronized会让程序的执行效率降低，用户体验不好。
        系统的用户吞吐量降低，用户体验差，在不得已的情况下再选择线程同步机制。
        第一种方案：尽量使用局部变量来代替实例变量和静态变量；
        第二种方案：如果必须是实例变量，那么可以考虑创建多个对象，这样实例变量的内存就不共享了。
        第三种方案：如果不能使用局部变量，对象也不能创建多个，这个时候就只能使用线程同步机制了。

    7、线程这块还有哪些内容？
        7.1、守护线程；
            java语言中线程分为两大类：
                一类是：用户线程；
                一类是：守护线程（后台线程）
                其中具有代表性的是：垃圾回收线程（守护线程）

                守护线程的特点：
                    一般守护线程是一个死循环，所有的用户线程只要结束，守护线程自动结束；

                    注意：main方法是一个用户线程。
                守护线程用在什么地方呢？

        7.2、定时器；
            作用：
            间隔特定的时间执行特定的程序；

        7.3、实现线程的第三种方式：FutrueTask方式，实现Callable接口（JDK8新特性）
                这种方式实现的线程可以获取线程的返回值；
                之前讲解的那两种方式是无法获取线程返回值的。因为run方法返回void。
        7.4、关于Object类中的wait和notify方法 （生产者和消费者模式）
            第一：wait和notify方法不是线程对象的方法，是java中任何一个对象都有的方法，因为这
            两个方法是Object类中自带的。
            wait方法和notify方法不是通过线程对象调用，
            这样：t.wait(), t.notify(), 这样都不对
            第二：wait() 方法的作用？
                Object o = new Object();
                o.wait();
                表示：让正在o对象上活动的线程进入等待状态，无期限等待，直到被唤醒。
                o.wait(); 方法的调用，会让“当前线程(正在o对象上活动的线程)”进入等待状态
            第三：notify() 方法的作用？
                Object o = new Object();
                o.notify();
                表示：
                    唤醒正在o对象上等待的线程。
                还有一个notifyAll()方法：
                    这个方法是唤醒o对象上出于等待的所有线程。